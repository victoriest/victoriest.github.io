<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Victoriest's Lab</title>
  <meta name="theme-color" content="#222222" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="http://victoriest.me/js/jquery.min.js"></script>
  <script src="http://victoriest.me/js/bootstrap.min.js"></script>
  <script src="http://victoriest.me/js/header.js"></script>
  <script src="http://victoriest.me/js/toc.js"></script>
  <link href="http://victoriest.me/css/bootstrap.min.css" rel="stylesheet">
  <link href="http://victoriest.me/css/theme.css" rel="stylesheet">
  <link href="http://victoriest.me/css/syntax.css" rel="stylesheet">
  <link href="http://victoriest.me/css/font-awesome/css/font-awesome.min.css" rel="stylesheet">
</head>

<body>

  

  


 <script type="text/javascript">
  WebFontConfig = {
    google: {
      families: ['Ubuntu::latin']
    }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://victoriest.me/">Victoriest's Lab</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="http://victoriest.me/index.html">Home</a></li>
          <li><a href="http://victoriest.me/memo.html">Memo</a></li>
          <li><a href="http://victoriest.me/archive.html">Archive</a></li>
          <!--<li><a href="http://victoriest.me/tags.html">Tags</a></li>-->
          <li><a href="http://victoriest.me/about.html">About</a></li>
        </ul>
      </div>
    </div>
  </nav>


<div class="wrapper">
  <div class="content">
    <div class="container container-center">
      <div class="row">
        <div class="col-md-8">
          <div class="article">
            <div class="well">
              <h1><a href="http://victoriest.me/2017/03/CLOJURE-for-the-BRAVE-and-TRUE-Chapter-02-%E8%AF%91">CLOJURE-for-the-BRAVE-and-TRUE-Chapter-02[译]</a></h1>
              <div class="post-meta">
                <div class="post-time">
                  <i class="fa fa-calendar"></i>
                  <time>2017-03-03</time>
                </div>
                <!--
                <ul>
                  
                    <li><a href="http://victoriest.me/tag/clojure">clojure</a></li>
                  
                </ul>
                -->
              </div>
              <div class="post-content">
                <div id="toc" class="toc"></div>
                <h1 id="clojure">搞事情 : Clojure急速教程</h1>

<p>是时候学着用Clojure搞些事情了! 虽然你肯定知道Clojure的并发支持和其他的一些特性很叼, 但Clojure的最突出的特性是: 它是个Lisp. 本章中, 你将探索关于Lisp的核心元素:语法, 函数和数据(syntax, functions, and data). 它们会为你使用Clojure提供坚实的基础.</p>

<p>在打下基础后, 你将会开始写一些超关键的代码. 本章的最后一节中, 你将运用你学到的所有知识来创建一个hobbit的模型( a model of a hobbit)并提供一个随机点击的函数.</p>

<p>当读完本章后, 我建议你在REPL中实践这些示例. 学习一门新的语言就像骑车游泳一样, 你必须自己去实践.</p>

<h2 id="section">语法</h2>

<p>Clojure的语法很简单. 像所有其他的Lisp方言一样, 它们有统一的结构, 少量的特殊操作符, 以及无尽的圆括号…</p>

<h3 id="forms">Forms</h3>

<p>所有的Clojure代码由两种结构组成:</p>

<ul>
  <li>数据(numbers, strings, maps, and vectors)</li>
  <li>操作符</li>
</ul>

<p>我们使用术语<strong>form</strong>来指代有效的代码. 有时, 我们也使用<strong>expression</strong>来引用<strong>form</strong>. Clojure会计算(<strong>evaluates **)每个</strong>form<strong>的值. 以下是一些有效</strong>form**的例子:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="mi">1</span><span class="w">
</span><span class="s">"a string"</span><span class="w">
</span><span class="p">[</span><span class="s">"a"</span><span class="w"> </span><span class="s">"vector"</span><span class="w"> </span><span class="s">"of"</span><span class="w"> </span><span class="s">"strings"</span><span class="p">]</span><span class="w">
</span></code></pre>
</div>

<p>你的代码很少会单独出现类似于上面的数据, 因为, 它们单独存在是并不能有什么作用. 所以, 你需要使用操作符(operations). <strong>Operations</strong>告诉你具体搞什么事情. 所有操作有以下形式:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">operator</span><span class="w"> </span><span class="n">operand1</span><span class="w"> </span><span class="n">operand2</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="n">operandn</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>需注意的是, operator之间是没有逗号的, Clojure使用空格来隔开它们, 并且会把逗号视为空格. 示例如下:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 6
</span><span class="w">
</span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"It was the panda "</span><span class="w"> </span><span class="s">"in the library "</span><span class="w"> </span><span class="s">"with a dust buster"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "It was the panda in the library with a dust buster"
</span></code></pre>
</div>

<p>第一个form, 将运算符<code class="highlighter-rouge">+</code>会依次对运算数<code class="highlighter-rouge">1</code>, <code class="highlighter-rouge">2</code>, <code class="highlighter-rouge">3</code>做加法运算. 第二个form, 函数<code class="highlighter-rouge">str</code>拼接三个字符串构成新字符串. 它们都是有效的form. 下面的这个不是一个有效的form, 因为它没有右括号：</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">+</span><span class="w">
</span></code></pre>
</div>

<p>Clojure的语法结构可能让你有点不适. 其他的语言里, 不同的操作符的操作数可能不相同. 比如如下的js代码, 用中缀记法来表达<code class="highlighter-rouge">+</code>, 用<code class="highlighter-rouge">.</code>和圆括号来表达函数调用:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
<span class="s2">"It was the panda "</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="s2">"in the library "</span><span class="p">,</span> <span class="s2">"with a dust buster"</span><span class="p">)</span>
</code></pre>
</div>

<p>Clojure的语法结构非常简单且统一, 不管什么操作, 它的结构都是统一的.</p>

<h3 id="section-1">控制流</h3>

<p>我们先从3个基本的控制流操作符开始 : <code class="highlighter-rouge">if</code>, <code class="highlighter-rouge">do</code>, <code class="highlighter-rouge">when</code>.</p>

<h4 id="if">if</h4>

<p>下面是一个<code class="highlighter-rouge">if</code>表达式的基本结构:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">boolean-form</span><span class="w">
  </span><span class="n">then-form</span><span class="w">
  </span><span class="n">optional-else-form</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>一个<strong>boolean-form</strong>是一个只会返回<code class="highlighter-rouge">true</code>或<code class="highlighter-rouge">false</code>的form. 下一节里你会学到关于真值和假值的知识. 下面是几个关于<code class="highlighter-rouge">if</code>的例子:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="s">"By Zeus's hammer!"</span><span class="w">
  </span><span class="s">"By Aquaman's trident!"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "By Zeus's hammer!"
</span><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">false</span><span class="w">
  </span><span class="s">"By Zeus's hammer!"</span><span class="w">
  </span><span class="s">"By Aquaman's trident!"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "By Aquaman's trident!"
</span></code></pre>
</div>
<p>第一个例子会返回<code class="highlighter-rouge">"By Zeus's hammer!"</code>, 因为boolean-form的计算结果是<code class="highlighter-rouge">true</code>; 第二个例子则相反, boolean-form的计算结果是<code class="highlighter-rouge">false</code>, 所以它返回<code class="highlighter-rouge">"By Aquaman's trident!"</code>.</p>

<p>你可以忽略<code class="highlighter-rouge">else</code>语句分支, 但如果boolean-form的计算结果是<code class="highlighter-rouge">false</code>, 则会返回<code class="highlighter-rouge">nil</code>. 像这样:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">false</span><span class="w">
  </span><span class="s">"By Odin's Elbow!"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; nil
</span></code></pre>
</div>

<p>需要注意与大多数语言不通的是, <strong>then-form</strong>和<strong>else-form</strong>分别只能有一个表达式(form). 比如在ruby中你可以这样写:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="kp">true</span>
  <span class="n">doer</span><span class="p">.</span><span class="nf">do_thing</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">doer</span><span class="p">.</span><span class="nf">do_thing</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">else</span>
  <span class="n">other_doer</span><span class="p">.</span><span class="nf">do_thing</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">other_doer</span><span class="p">.</span><span class="nf">do_thing</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<p>但在Clojure中, 想要<code class="highlighter-rouge">if</code>分支或者<code class="highlighter-rouge">else</code>分支中有多个表达式的话, 则需要运算符<code class="highlighter-rouge">do</code>.</p>

<!--more-->

<h4 id="do">do</h4>

<p>运算符<code class="highlighter-rouge">do</code>允许你执行括号内的多个form:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="p">(</span><span class="nf">do</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Success!"</span><span class="p">)</span><span class="w">
      </span><span class="s">"By Zeus's hammer!"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">do</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Failure!"</span><span class="p">)</span><span class="w">
      </span><span class="s">"By Aquaman's trident!"</span><span class="p">))</span><span class="w">
</span><span class="c1">; =&gt; Success!
; =&gt; "By Zeus's hammer!"
</span></code></pre>
</div>

<h4 id="when">when</h4>

<p><code class="highlighter-rouge">when</code>就像<code class="highlighter-rouge">if</code>和<code class="highlighter-rouge">do</code>的组合, 但是它没有else分支, 例:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Success!"</span><span class="p">)</span><span class="w">
  </span><span class="s">"abra cadabra"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; Success!
; =&gt; "abra cadabra"
</span></code></pre>
</div>

<p>如果<code class="highlighter-rouge">when</code>判断结果为<code class="highlighter-rouge">false</code>, 则表达式返回<code class="highlighter-rouge">nil</code>.</p>

<h4 id="nil-true-false-truthiness-equality-and-boolean-expressions">nil, true, false, Truthiness, Equality, and Boolean Expressions</h4>

<p>Clojure中 真值, 假值, 空值分别以<code class="highlighter-rouge">true</code>,<code class="highlighter-rouge">false</code>,<code class="highlighter-rouge">nil</code>表示. 可用使用函数<code class="highlighter-rouge">nil?</code>判断一个值是否为空:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; false
</span><span class="w">
</span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; true
</span></code></pre>
</div>

<p>逻辑计算中, <code class="highlighter-rouge">nil</code>和<code class="highlighter-rouge">false</code>都为假, 其他值为真. 例:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="s">"bears eat beets"</span><span class="w">
  </span><span class="s">"bears beets Battlestar Galactica"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "bears beets Battlestar Galactica"
</span><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">nil</span><span class="w">
  </span><span class="s">"This won't be the result because nil is falsey"</span><span class="w">
  </span><span class="s">"nil is falsey"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "nil is falsey"
</span></code></pre>
</div>

<p>Clojure中表达式是否相等的比较运算符用<code class="highlighter-rouge">=</code>表示:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; false
</span></code></pre>
</div>

<p>一些其他的语言可能会使用不同的比较运算符来对应不同的数据结构, 比如可能使用特定的比较函数来比较字符串. 但在Clojure中, 你不必担心这个问题, clojure的内建数据结构都会使用同一的比较运算符.</p>

<p>Clojure提供运算符<code class="highlighter-rouge">or</code>, <code class="highlighter-rouge">and</code>; <code class="highlighter-rouge">or</code>返回form中第一个真值或最后一个值; <code class="highlighter-rouge">and</code>返回第一个假值或最后一个值:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:large_I_mean_venti</span><span class="w"> </span><span class="no">:why_cant_I_just_say_large</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; :large_I_mean_venti
</span><span class="w">
</span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"yes"</span><span class="w"> </span><span class="s">"no"</span><span class="p">))</span><span class="w">
</span><span class="c1">; =&gt; false
</span><span class="w">
</span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="no">:free_wifi</span><span class="w"> </span><span class="no">:hot_coffee</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; :hot_coffee
</span><span class="w">
</span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="no">:feelin_super_cool</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="n">false</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; nil
</span></code></pre>
</div>

<h4 id="defvalue">用<code class="highlighter-rouge">def</code>给value起名字</h4>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">failed-protagonist-names</span><span class="w">
  </span><span class="p">[</span><span class="s">"Larry Potter"</span><span class="w"> </span><span class="s">"Doreen the Explorer"</span><span class="w"> </span><span class="s">"The Incredible Bulk"</span><span class="p">])</span><span class="w">

</span><span class="n">failed-protagonist-names</span><span class="w">
</span><span class="c1">; =&gt; ["Larry Potter" "Doreen the Explorer" "The Incredible Bulk"]
</span></code></pre>
</div>

<p>上例中, 我们给一个含有3个字符串的vector绑定到名称<code class="highlighter-rouge">failed-protagonist-names</code>上. (vector后面会讲到)</p>

<p>注意, 我们使用术语<strong>绑定</strong>(bind), 在其他语言中被称为赋值给一个变量, 因为通常在其他语言里变量可以多次赋值的. (译者: 不变性, 是函数式语言的主要特点之一)</p>

<p>在ruby中, 你可以为一个变量多次赋值:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">severity</span> <span class="o">=</span> <span class="ss">:mild</span>
<span class="n">error_message</span> <span class="o">=</span> <span class="s2">"OH GOD! IT'S A DISASTER! WE'RE "</span>
<span class="k">if</span> <span class="n">severity</span> <span class="o">==</span> <span class="ss">:mild</span>
  <span class="n">error_message</span> <span class="o">=</span> <span class="n">error_message</span> <span class="o">+</span> <span class="s2">"MILDLY INCONVENIENCED!"</span>
<span class="k">else</span>
  <span class="n">error_message</span> <span class="o">=</span> <span class="n">error_message</span> <span class="o">+</span> <span class="s2">"DOOOOOOOMED!"</span>
<span class="k">end</span>
</code></pre>
</div>
<p>你可以在Clojure中做类似的事情:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">severity</span><span class="w"> </span><span class="no">:mild</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">error-message</span><span class="w"> </span><span class="s">"OH GOD! IT'S A DISASTER! WE'RE "</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">severity</span><span class="w"> </span><span class="no">:mild</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">error-message</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">error-message</span><span class="w"> </span><span class="s">"MILDLY INCONVENIENCED!"</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">error-message</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">error-message</span><span class="w"> </span><span class="s">"DOOOOOOOMED!"</span><span class="p">)))</span><span class="w">
</span></code></pre>
</div>

<p>更改一个名称所关联的值, 会使程序的变得难以理解. 虽然Clojure提供了一系列的工具来处理类似于变量的东西, 但随着你深入学习, 你会发现你很少需要改变一个名字所代表的的值. 这里提供一个上例中比较好的解决方法:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">error-message</span><span class="w">
  </span><span class="p">[</span><span class="n">severity</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"OH GOD! IT'S A DISASTER! WE'RE "</span><span class="w">
       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">severity</span><span class="w"> </span><span class="no">:mild</span><span class="p">)</span><span class="w">
         </span><span class="s">"MILDLY INCONVENIENCED!"</span><span class="w">
         </span><span class="s">"DOOOOOOOMED!"</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">error-message</span><span class="w"> </span><span class="no">:mild</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "OH GOD! IT'S A DISASTER! WE'RE MILDLY INCONVENIENCED!"
</span></code></pre>
</div>

<p>这里, 我们创建了一个名为<code class="highlighter-rouge">error-message</code>的函数, 它接受单个参数<code class="highlighter-rouge">severity</code>, 并用这个参数判断返回哪个字符串. 后面你会学到如何创建一个函数, 这里你需要知道<code class="highlighter-rouge">def</code>是用来定义常量的. 接下来的几章里, 你会学到如何利用函数式编程的特性来取代变量.</p>

<h3 id="section-2">数据结构</h3>

<p>Clojure提供了几个最常用的数据结构. 如果你有过面向对象编程语言的背景, 你会惊讶于这些看似简单的结构能够做如此多的事情.</p>

<p>所有的Clojure的数据结构都是不可变的, 下面是个ruby的例子, 它修改数组下表为0的元素的值:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">failed_protagonist_names</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s2">"Larry Potter"</span><span class="p">,</span>
  <span class="s2">"Doreen the Explorer"</span><span class="p">,</span>
  <span class="s2">"The Incredible Bulk"</span>
<span class="p">]</span>
<span class="n">failed_protagonist_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Gary Potter"</span>

<span class="n">failed_protagonist_names</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#   "Gary Potter",</span>
<span class="c1">#   "Doreen the Explorer",</span>
<span class="c1">#   "The Incredible Bulk"</span>
<span class="c1"># ]</span>
</code></pre>
</div>

<p>Clojure中没有等效的表达, 你会在第10章中知道在clojure中如何实现上述功能.</p>

<h4 id="section-3">数字</h4>

<p>Clojure对数字有复杂的支持, 我们不会花时间在它的技术系节里, 因为这会影响我们”搞事情”. 如果你对这些细节感兴趣, 看看文档<a href="http://clojure.org/data_structures#Data%20Structures-Numbers">http://clojure.org/data_structures#Data%20Structures-Numbers</a>. 所以你只要知道Clojure会给你正确的结果就够了. 比如下面, 整数, 浮点数, 以及比率:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="mi">93</span><span class="w">
</span><span class="mf">1.2</span><span class="w">
</span><span class="mi">1</span><span class="n">/5</span><span class="w">
</span></code></pre>
</div>

<h4 id="section-4">字符串</h4>

<p>字符串你懂的, 这个名字来自古老的腓尼基人; 下面是几个例子:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="s">"Lord Voldemort"</span><span class="w">
</span><span class="s">"\"He who must not be named\""</span><span class="w">
</span><span class="s">"\"Great cow of Moscow!\" - Hermes Conrad"</span><span class="w">
</span></code></pre>
</div>

<p>Clojure值允许使用双引号来代表字符串. 如<code class="highlighter-rouge">'Lord Voldemort'</code>并不是一个合法的字符串. 而且Clojure中没有插入字符串的方法, 只有拼接字符串的方法<code class="highlighter-rouge">str</code>:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="s">"Chewbacca"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"\"Uggllglglglglglglglll\" - "</span><span class="w"> </span><span class="nb">name</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "Uggllglglglglglglglll" - Chewbacca
</span></code></pre>
</div>

<h4 id="maps">Maps</h4>

<p>Maps类似于其他语言的字典(dictionaries)或哈希(hashes). 他是关联两个值的方式之一. Clojure有两种Map : hash map和sorted map. 下面是个空的map:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">{}</span><span class="w">
</span></code></pre>
</div>

<p>下例中,  <code class="highlighter-rouge">:first-name</code> and <code class="highlighter-rouge">:last-name</code> 是关键字:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="no">:first-name</span><span class="w"> </span><span class="s">"Charlie"</span><span class="w">
 </span><span class="no">:last-name</span><span class="w"> </span><span class="s">"McFishwich"</span><span class="p">}</span><span class="w">
 </span><span class="o">```</span><span class="w">

</span><span class="err">我们可以将</span><span class="o">`</span><span class="s">"string-key"</span><span class="o">`</span><span class="err">和运算符</span><span class="o">`</span><span class="nb">+</span><span class="o">`</span><span class="err">关联起来:</span><span class="w">

</span><span class="o">```</span><span class="n">clojure</span><span class="w">
</span><span class="p">{</span><span class="s">"string-key"</span><span class="w"> </span><span class="nb">+</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>Map可以嵌套:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="p">{</span><span class="no">:first</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="no">:middle</span><span class="w"> </span><span class="s">"Jacob"</span><span class="w"> </span><span class="no">:last</span><span class="w"> </span><span class="s">"Jingleheimerschmidt"</span><span class="p">}}</span><span class="w">
</span></code></pre>
</div>
<p>map的值中可以是任何类型(strings, numbers, maps, vectors, even functions).</p>

<p>除了使用<code class="highlighter-rouge"><span class="p">{}</span></code>, 你还可以用<code class="highlighter-rouge">hash-map</code>函数来创建一个map:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">hash-map</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; {:a 1 :b 2}
</span></code></pre>
</div>

<p>用<code class="highlighter-rouge">get</code>方法在map中获取一个元素的值:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="no">:b</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 1
</span><span class="w">
</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="p">{</span><span class="no">:c</span><span class="w"> </span><span class="s">"ho hum"</span><span class="p">}}</span><span class="w"> </span><span class="no">:b</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; {:c "ho hum"}
</span></code></pre>
</div>

<p>如果没有指定的键<code class="highlighter-rouge">get</code>方法返回<code class="highlighter-rouge">nil</code>, 或者你可以指定一个默认值 如下例中的<code class="highlighter-rouge">"unicorns?"</code>:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="s">"unicorns?"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "unicorns?"
</span></code></pre>
</div>

<p><code class="highlighter-rouge">get-in</code>函数可以获取嵌套Map的值:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="p">{</span><span class="no">:c</span><span class="w"> </span><span class="s">"ho hum"</span><span class="p">}}</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">])</span><span class="w">
</span><span class="c1">; =&gt; "ho hum"
</span></code></pre>
</div>

<p>下面是另一种从Map取值的方式:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">({</span><span class="no">:name</span><span class="w"> </span><span class="s">"The Human Coffeepot"</span><span class="p">}</span><span class="w"> </span><span class="no">:name</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "The Human Coffeepot"
</span></code></pre>
</div>

<p>你可以使用关键字作为函数来查找他们的值.</p>

<h4 id="section-5">关键字</h4>

<p>如你所见关键字就是看起来如下这样. 它主要用作为key在map中:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="no">:a</span><span class="w">
</span><span class="no">:rumplestiltsken</span><span class="w">
</span><span class="no">:34</span><span class="w">
</span><span class="no">:_?</span><span class="w">
</span></code></pre>
</div>

<p>关键字可以作为查找数据结构中对应的值的函数. 如下例, <code class="highlighter-rouge">a</code>可以查找map中的值:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="no">:a</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="c1">; =&gt; 1
</span></code></pre>
</div>

<p>等效于:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 1
</span></code></pre>
</div>

<p>像使用<code class="highlighter-rouge">get</code>一样, 你可以给一个默认值, 当它找不到相应键的时候会返回默认值:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="no">:d</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="s">"No gnome knows homes like Noah knows"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "No gnome knows homes like Noah knows"
</span></code></pre>
</div>

<p>把关键字当做函数在Clojure开发者中非常常见, 你也应该加入他们.</p>

<h4 id="vectors">Vectors</h4>

<p>vector非常像数组, 下标从0开始. 如下例:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w">
</span></code></pre>
</div>

<p>我们返回vector中下标0的元素可以用<code class="highlighter-rouge">get</code>:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 3
</span></code></pre>
</div>

<p>另外的一些例子:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">[</span><span class="s">"a"</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Pugsley Winterbottom"</span><span class="p">}</span><span class="w"> </span><span class="s">"c"</span><span class="p">]</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; {:name "Pugsley Winterbottom"}
</span></code></pre>
</div>
<p>vector中的元素可以是任何类型, 并且不同的类型可以混到一个vector里. 并且我们同样使用<code class="highlighter-rouge">get</code>函数来查找数组中的元素.</p>

<p>使用<code class="highlighter-rouge">vector</code>函数来创建一个vector:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">vector</span><span class="w"> </span><span class="s">"creepy"</span><span class="w"> </span><span class="s">"full"</span><span class="w"> </span><span class="s">"moon"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; ["creepy" "full" "moon"]
</span></code></pre>
</div>

<p>使用<code class="highlighter-rouge">conj</code>函数来向vector中添加元素到vector的末尾:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; [1 2 3 4]
</span></code></pre>
</div>

<p>除了vector, list也是Clojure用来储存序列的数据结构.</p>

<h4 id="lists">Lists</h4>

<p>list与vector类似. 但也有不同. 比如, 你不用使用<code class="highlighter-rouge">get</code>方法获取list的中的元素. 在一对圆括号前加上<code class="highlighter-rouge">'</code>, 他就是个list了:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; (1 2 3 4)
</span></code></pre>
</div>

<p>REPL中, list的输出不包含<code class="highlighter-rouge">'</code>. 这个第七章的时候讲. 如果你想获取list中的某个元素, 可以使用<code class="highlighter-rouge">nth</code>函数:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; :a
</span><span class="w">
</span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; :c
</span></code></pre>
</div>

<p>在你熟悉一门语言之前, 我是不会去谈论一些性能细节的, 没必要. 但你最好知道, 从一个vector中使用<code class="highlighter-rouge">get</code>获取元素要比list中使用’nth’获取元素速度要快一些. 因为list需要遍历n个元素, 而vector只需要获取下标的索引.</p>

<p>list的元素可以是任何类型, 使用<code class="highlighter-rouge">list</code>函数可以创建一个list:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"two"</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">})</span><span class="w">
</span><span class="c1">; =&gt; (1 "two" {3 4})
</span></code></pre>
</div>

<p>用<code class="highlighter-rouge">conj</code>添加元素到list中, 会添加到list的头, 而不是尾:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; (4 1 2 3)
</span></code></pre>
</div>

<p>那么, 什么时候改使用list而什么是偶使用vector呢? 如果你需要方便的将元素添加到一个序列的开头, 或者你正在编写一个宏, 你需要的是list. 其他情况, 则用vector. 随着学习的深入, 你自然而然就知道该用啥了.</p>

<h4 id="sets">Sets</h4>

<p>set是一种序列对象, 序列中每个值都是唯一的, 不重复. 有两种set: hash set 和 sorted set. 先来关注下我们最常用的hash set:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="o">#</span><span class="p">{</span><span class="s">"kurt vonnegut"</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="no">:icicle</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>同样, 使用<code class="highlighter-rouge">hash-set</code>也可以来创建一个set:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">hash-set</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; #{1 2}
</span></code></pre>
</div>

<p>set中的值是唯一的, 所以上例中, 只有一个<code class="highlighter-rouge">1</code>和一个<code class="highlighter-rouge">2</code>. 如果你添加重复的元素, 会忽略重复的元素:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="p">}</span><span class="w"> </span><span class="no">:b</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; #{:a :b}
</span></code></pre>
</div>

<p>你可以通过<code class="highlighter-rouge">set</code>函数从已有的vector或list创建一个set:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span><span class="c1">; =&gt; #{3 4}
</span></code></pre>
</div>

<p>使用<code class="highlighter-rouge">contains?</code>函数判断一个元素是否在集合中存在:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="p">}</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; false
</span><span class="w">
</span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="n">nil</span><span class="p">}</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; true
</span></code></pre>
</div>

<p>set使用关键字的例子:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="no">:a</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="p">})</span><span class="w">
</span><span class="c1">; =&gt; :a
</span></code></pre>
</div>

<p>使用<code class="highlighter-rouge">get</code>的例子:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; :a
</span><span class="w">
</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="p">}</span><span class="w"> </span><span class="s">"kurt vonnegut"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; nil
</span></code></pre>
</div>

<p>注意，使用<code class="highlighter-rouge">get</code>来查看set是否包含nil将总是返回nil，这是令人困惑的. <code class="highlighter-rouge">contains?</code>可能是更好的选择.</p>

<h4 id="simplicity">Simplicity</h4>

<p>你可能注意到了迄今为止讲到的的所有数据类型中, 没有提到关于如何创建一个新类型或者class. 因为, Clojure世界中会鼓励你去优先使用内建对象.</p>

<p>如果你之前是有OO背景的开发者, 你可能觉得很怪. 然而, 数据和数据类型的分离可是使其更加方便和易懂. 下面的话正代表了CLojure的哲学:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
—Alan Perlis
</code></pre>
</div>
<p>你会慢慢的了解到更多的Clojure的哲学. 现在你知道了, 使用基本的数据结构可以使你的代码变得可重用.</p>

<p>到此为止就是所有的Clojure的数据结构了. 接下来该学着如何使用它们了.</p>

<h3 id="functions">Functions</h3>

<p>许多人坚持使用Lisp语系语言的原因之一, 就是它的主要构件模块function很简单, 但却能建立复杂的程序. 本节会介绍关于lisp函数的如下方面:</p>

<ul>
  <li>调用函数</li>
  <li>函数与宏(macros)和特殊表单(special forms)的区别</li>
  <li>定义函数</li>
  <li>匿名函数</li>
  <li>返回一个函数</li>
</ul>

<h4 id="calling-functions">Calling Functions</h4>

<p>迄今为止我们已经看过不少函数调用的示例了:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span></code></pre>
</div>

<p>记住所有的Clojure命令都有相同的语法:<code class="highlighter-rouge">(operator operands1 ...)</code>. 函数的调用只是把<strong>operator</strong>换成了函数, 或者函数表达式(返回值是一个函数的表达式).</p>

<p>这让我们可以写一些非常有意思的代码. 如下是个返回<code class="highlighter-rouge">+</code>函数的一个函数表达式(function expresssion):</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="nb">-</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; #&lt;core$_PLUS_ clojure.core$_PLUS_@76dace31&gt;
</span></code></pre>
</div>

<p>这个返回值是<code class="highlighter-rouge">+</code>函数的字符串形式的描述. 你还可以使用这个表达式作为另一个表达式的运算符:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">((</span><span class="nb">or</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="nb">-</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 6
</span></code></pre>
</div>

<p><code class="highlighter-rouge">(or + -)</code> 返回 <code class="highlighter-rouge">+</code>, 所以这个表达式的结果是把 <code class="highlighter-rouge">1</code>, <code class="highlighter-rouge">2</code>, <code class="highlighter-rouge">3</code>相加, 返回6.</p>

<p>下面是一些其他的合法调用:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">((</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="nb">+</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 6
</span><span class="w">
</span><span class="p">((</span><span class="nb">first</span><span class="w"> </span><span class="p">[</span><span class="nb">+</span><span class="w"> </span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 6
</span></code></pre>
</div>

<p>数字和字符串不能作为函数, 以下是些非法示例:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="s">"test"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>如果你在REPL中执行它们, 会返回类似于这样的东西:</p>

<p>ClassCastException java.lang.String cannot be cast to clojure.lang.IFn</p>
<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="n">user/eval728</span><span class="w"> </span><span class="p">(</span><span class="nf">NO_SOURCE_FILE</span><span class="no">:1</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>你在今后可能会经常看到类似的提示: <x> cannot be cast to clojure.lang.IFn, 意思就是你把一个不是函数的东西当做函数来用了.</x></p>

<p>函数的灵活性并不仅仅只是函数表达式! 在语法意义上，函数可以将任何表达式作为参数 - 包括其他函数. 可以将函数作为参数或返回函数这样的函数被称为高阶函数(higher-order functions). 具有高阶函数的编程语言被称为first-class functions, 这些语言可以用与操作数字和vector一样的方式去操作函数.</p>

<p><code class="highlighter-rouge">map</code>函数(别与数据结构map搞混了)会分别对集合内的每个对象求值并返回一根新的list. 如下例, 对vector里的每个元素+1:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mf">1.1</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 2.1
</span><span class="w">
</span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="c1">; =&gt; (1 2 3 4)
</span></code></pre>
</div>

<p>注意及时你参数传入一个vector, <code class="highlighter-rouge">map</code>也不会返回一个vector, 细节将在第4章里讲到.</p>

<p>Clojure将函数作为一等公民, 这为clojure带来在相较其他语言里更强大的抽象能力. Those unfamiliar with this kind of programming think of functions as allowing you to generalize operations over data instances. For example, the <code class="highlighter-rouge">+</code> function abstracts addition over any specific numbers.</p>

<p>By contrast, Clojure (and all Lisps) allows you to create functions that generalize over processes. <code class="highlighter-rouge">map</code> allows you to generalize the process of transforming a collection by applying a function—any function—over any collection.</p>

<p>另外有个细节, Clojure的函数调用会递归的计算每个函数参数内表达式的值:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">199</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="w"> </span><span class="c1">; evaluated "(inc 199)"
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluated (- 7 2)
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluated (/ 100 5)
</span><span class="mi">220</span><span class="w"> </span><span class="c1">; final evaluation
</span></code></pre>
</div>
<p>函数调用启动了计算, 并且会计算每个子表达式的值.</p>

<h4 id="function-calls-macro-calls-and-special-forms">Function Calls, Macro Calls, and Special Forms</h4>

<p>上一节里, 你了解了函数调用以及将函数表达式作为操作符的形式的函数调用. 另外两种表达式为宏调用和特殊form. 其实你已经见过了一些特殊form: 定义 和 <code class="highlighter-rouge">if</code>表达式.</p>

<p>第7章中, 你会学习所有关于宏调用和特殊form的知识. 而特殊form相较于函数调用的最主要的特殊之处在于, <strong>特殊form并不总是计算所有的子表达式</strong>.</p>

<p>用<code class="highlighter-rouge">if</code>作为例子, 他的一般形式是这样的:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">boolean-form</span><span class="w">
  </span><span class="n">then-form</span><span class="w">
  </span><span class="n">optional-else-form</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>假如你写了一个如下的<code class="highlighter-rouge">if</code>语句:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">good-mood</span><span class="w">
  </span><span class="p">(</span><span class="nf">tweet</span><span class="w"> </span><span class="n">walking-on-sunshine-lyrics</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">tweet</span><span class="w"> </span><span class="n">mopey-country-song-lyrics</span><span class="p">))</span><span class="w">
</span></code></pre>
</div>

<p>显然, 这个<code class="highlighter-rouge">if</code>表达式中我们希望Clojure只计算两个选择分支中的一个分支的内容. 如果Clojure执行所有的两个分支, 关注你Twitter人会懵逼.</p>

<p>另一个特殊form的特征: 不能将他们作为函数的参数. 通常, 特殊form实现了函数不能实现的Clojure的核心功能. (译者: 下面又是对Clojure的惊叹, 不翻译了)</p>

<p>宏与特殊form类似, 不能作为函数参数传入.</p>

<h4 id="defining-functions">Defining Functions</h4>

<p>函数定义有5部分:</p>

<ul>
  <li>defn关键字</li>
  <li>函数名</li>
  <li>描述函数的文档字符串（可选）</li>
  <li>参数列表</li>
  <li>函数体</li>
</ul>

<p>下面是个函数定义以及调用这个函数的例子:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="err">➊</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">too-enthusiastic</span><span class="w">
</span><span class="err">➋</span><span class="w">   </span><span class="s">"Return a cheer that might be a bit too enthusiastic"</span><span class="w">
</span><span class="err">➌</span><span class="w">   </span><span class="p">[</span><span class="nb">name</span><span class="p">]</span><span class="w">
</span><span class="err">➍</span><span class="w">   </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"OH. MY. GOD! "</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="s">" YOU ARE MOST DEFINITELY LIKE THE BEST "</span><span class="w">
  </span><span class="s">"MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">too-enthusiastic</span><span class="w"> </span><span class="s">"Zelda"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "OH. MY. GOD! Zelda YOU ARE MOST DEFINITELY LIKE THE BEST MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE"
</span></code></pre>
</div>
<p>第➊行, <code class="highlighter-rouge">too-enthusiastic</code>是这个函数的名字, ➋是函数的描述文档. ➌是函数的参数列表, ➍为函数体. 下面我们深入到每个部分看一下.</p>

<h4 id="section-6">描述函数的文档</h4>

<p>描述文档是以一个给你的函数添加文档的好方法, 在REPL里 使用<code class="highlighter-rouge">doc</code>函数来查看某个函数的描述文档. 比如<code class="highlighter-rouge">(doc map)</code>, 可以查看函数<code class="highlighter-rouge">map</code>的文档.</p>

<h4 id="parameters-and-arity">Parameters and Arity</h4>

<p>Clojure函数可以定义零到多个参数, 参数的可以是任意的数据类型的. 下面是些例子:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">no-params</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="s">"I take no parameters!"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">one-param</span><span class="w">
  </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"I take one parameter: "</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">two-params</span><span class="w">
  </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Two parameters! That's nothing! Pah! I will smoosh them "</span><span class="w">
  </span><span class="s">"together to spite you! "</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">
</span></code></pre>
</div>

<p>Functions also support arity overloading. This means that you can define a function so a different function body will run depending on the arity. Here’s the general form of a multiple-arity function definition. Notice that each arity definition is enclosed in parentheses and has an argument list:</p>

<p>函数支持参数重载, 意味着你可以根据参数数量不同定义不同的函数实现. 如下例:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">multi-arity</span><span class="w">
  </span><span class="c1">;; 3-arity arguments and body
</span><span class="w">  </span><span class="p">([</span><span class="n">first-arg</span><span class="w"> </span><span class="n">second-arg</span><span class="w"> </span><span class="n">third-arg</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">do-things</span><span class="w"> </span><span class="n">first-arg</span><span class="w"> </span><span class="n">second-arg</span><span class="w"> </span><span class="n">third-arg</span><span class="p">))</span><span class="w">
  </span><span class="c1">;; 2-arity arguments and body
</span><span class="w">  </span><span class="p">([</span><span class="n">first-arg</span><span class="w"> </span><span class="n">second-arg</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">do-things</span><span class="w"> </span><span class="n">first-arg</span><span class="w"> </span><span class="n">second-arg</span><span class="p">))</span><span class="w">
  </span><span class="c1">;; 1-arity arguments and body
</span><span class="w">  </span><span class="p">([</span><span class="n">first-arg</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">do-things</span><span class="w"> </span><span class="n">first-arg</span><span class="p">)))</span><span class="w">
</span></code></pre>
</div>

<p>参数重载是一种为参数提供默认值的方法. 如下例, “karate”是参数<code class="highlighter-rouge">chop-type</code>的默认值:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">x-chop</span><span class="w">
  </span><span class="s">"Describe the kind of chop you're inflicting on someone"</span><span class="w">
  </span><span class="p">([</span><span class="nb">name</span><span class="w"> </span><span class="n">chop-type</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"I "</span><span class="w"> </span><span class="n">chop-type</span><span class="w"> </span><span class="s">" chop "</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="s">"! Take that!"</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="nb">name</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">x-chop</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="s">"karate"</span><span class="p">)))</span><span class="w">
</span></code></pre>
</div>

<p>如果你传入两个参数, 函数就会忽略默认值”karate”:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">x-chop</span><span class="w"> </span><span class="s">"Kanye West"</span><span class="w"> </span><span class="s">"slap"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "I slap chop Kanye West! Take that!"
</span><span class="w">
</span></code></pre>
</div>

<p>如果你只传入一个参数:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">x-chop</span><span class="w"> </span><span class="s">"Kanye East"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "I karate chop Kanye East! Take that!"
</span></code></pre>
</div>

<p>你也可以让每个参数重载的函数体做完全不一样的事情:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">weird-arity</span><span class="w">
  </span><span class="p">([]</span><span class="w">
     </span><span class="s">"Destiny dressed you this morning, my friend, and now Fear is
     trying to pull off your pants. If you give up, if you give in,
     you're gonna end up naked with Fear just standing there laughing
     at your dangling unmentionables! - the Tick"</span><span class="p">)</span><span class="w">
  </span><span class="p">([</span><span class="n">number</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">number</span><span class="p">)))</span><span class="w">
</span></code></pre>
</div>

<p>Clojure也可以定义一个不定参数的函数. 不定参数列表之前以<code class="highlighter-rouge">&amp;</code>标注, 如下例➊处:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">codger-communication</span><span class="w">
  </span><span class="p">[</span><span class="n">whippersnapper</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Get off my lawn, "</span><span class="w"> </span><span class="n">whippersnapper</span><span class="w"> </span><span class="s">"!!!"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">codger</span><span class="w">
</span><span class="err">➊</span><span class="w">   </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">whippersnappers</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">codger-communication</span><span class="w"> </span><span class="n">whippersnappers</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">codger</span><span class="w"> </span><span class="s">"Billy"</span><span class="w"> </span><span class="s">"Anne-Marie"</span><span class="w"> </span><span class="s">"The Incredible Bulk"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; ("Get off my lawn, Billy!!!"
</span><span class="w">      </span><span class="s">"Get off my lawn, Anne-Marie!!!"</span><span class="w">
      </span><span class="s">"Get off my lawn, The Incredible Bulk!!!"</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>如你所见, 不定参数会表现为list形式. 普通参数与不定参数都存在的参数列表中, 不定参数必须最后:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">favorite-things</span><span class="w">
  </span><span class="p">[</span><span class="nb">name</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">things</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Hi, "</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="s">", here are my favorite things: "</span><span class="w">
       </span><span class="p">(</span><span class="nf">clojure.string/join</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="n">things</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">favorite-things</span><span class="w"> </span><span class="s">"Doreen"</span><span class="w"> </span><span class="s">"gum"</span><span class="w"> </span><span class="s">"shoes"</span><span class="w"> </span><span class="s">"kara-te"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "Hi, Doreen, here are my favorite things: gum, shoes, kara-te"
</span></code></pre>
</div>

<p>Clojure还有一种更加复杂的参数定义方法, 称为解构(destructuring).</p>

<h4 id="destructuring">Destructuring</h4>

<p>解构的基本意图是给一个集合中的多个元素绑定名称.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="c1">;; Return the first element of a collection
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-first</span><span class="w">
  </span><span class="p">[[</span><span class="n">first-thing</span><span class="p">]]</span><span class="w"> </span><span class="c1">; Notice that first-thing is within a vector
</span><span class="w">  </span><span class="n">first-thing</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">my-first</span><span class="w"> </span><span class="p">[</span><span class="s">"oven"</span><span class="w"> </span><span class="s">"bike"</span><span class="w"> </span><span class="s">"war-axe"</span><span class="p">])</span><span class="w">
</span><span class="c1">; =&gt; "oven"
</span></code></pre>
</div>
<p><code class="highlighter-rouge">my-first</code>函数中的<code class="highlighter-rouge">first-thing</code>与传入的vector中的第一个元素绑定.</p>

<p>那个向量就像一个巨大的标志，对Clojure说: “嘿! 此函数将接收列表或向量作为参数. 通过拆开我的参数结构, 并将有意义的名称与参数的不同部分相关联, 使我的生活更容易! “当解构矢量或列表时, 可以命名任意多的元素, 并使用rest参数(以下为机翻):</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">chooser</span><span class="w">
  </span><span class="p">[[</span><span class="n">first-choice</span><span class="w"> </span><span class="n">second-choice</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">unimportant-choices</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Your first choice is: "</span><span class="w"> </span><span class="n">first-choice</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Your second choice is: "</span><span class="w"> </span><span class="n">second-choice</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"We're ignoring the rest of your choices. "</span><span class="w">
                </span><span class="s">"Here they are in case you need to cry over them: "</span><span class="w">
                </span><span class="p">(</span><span class="nf">clojure.string/join</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="n">unimportant-choices</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">chooser</span><span class="w"> </span><span class="p">[</span><span class="s">"Marmalade"</span><span class="n">,</span><span class="w"> </span><span class="s">"Handsome Jack"</span><span class="n">,</span><span class="w"> </span><span class="s">"Pigpen"</span><span class="n">,</span><span class="w"> </span><span class="s">"Aquaman"</span><span class="p">])</span><span class="w">
</span><span class="c1">; =&gt; Your first choice is: Marmalade
; =&gt; Your second choice is: Handsome Jack
; =&gt; We're ignoring the rest of your choices. Here they are in case \
</span><span class="w">     </span><span class="n">you</span><span class="w"> </span><span class="n">need</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">cry</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">them</span><span class="err">:</span><span class="w"> </span><span class="n">Pigpen,</span><span class="w"> </span><span class="n">Aquaman</span><span class="w">
</span></code></pre>
</div>

<p>上例中, 不定参数<code class="highlighter-rouge">unimportant-choices</code>用来处理剩下的vector中除了前两个元素的其余元素.</p>

<p>你还可以解构map:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">announce-treasure-location</span><span class="w">
</span><span class="err">➊</span><span class="w">   </span><span class="p">[{</span><span class="n">lat</span><span class="w"> </span><span class="no">:lat</span><span class="w"> </span><span class="n">lng</span><span class="w"> </span><span class="no">:lng</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Treasure lat: "</span><span class="w"> </span><span class="n">lat</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Treasure lng: "</span><span class="w"> </span><span class="n">lng</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">announce-treasure-location</span><span class="w"> </span><span class="p">{</span><span class="no">:lat</span><span class="w"> </span><span class="mf">28.22</span><span class="w"> </span><span class="no">:lng</span><span class="w"> </span><span class="mf">81.33</span><span class="p">})</span><span class="w">
</span><span class="c1">; =&gt; Treasure lat: 28.22
; =&gt; Treasure lng: 81.33
</span></code></pre>
</div>

<p>看看➊行. <code class="highlighter-rouge">lat</code>为map中<code class="highlighter-rouge">:lat</code>所代表的值, <code class="highlighter-rouge">lng</code>为map中<code class="highlighter-rouge">:lng</code>所代表的值.</p>

<p>通常我们只是想在map中获取值忽略键, 所以下面是简化的写法:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">announce-treasure-location</span><span class="w">
  </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">lat</span><span class="w"> </span><span class="n">lng</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Treasure lat: "</span><span class="w"> </span><span class="n">lat</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Treasure lng: "</span><span class="w"> </span><span class="n">lng</span><span class="p">)))</span><span class="w">
</span></code></pre>
</div>

<p>你可以使用<code class="highlighter-rouge">:as</code>关键字来保留经过解构后的map的原本的数据:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">receive-treasure-location</span><span class="w">
  </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">lat</span><span class="w"> </span><span class="n">lng</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">treasure-location</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Treasure lat: "</span><span class="w"> </span><span class="n">lat</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Treasure lng: "</span><span class="w"> </span><span class="n">lng</span><span class="p">))</span><span class="w">

  </span><span class="c1">;; One would assume that this would put in new coordinates for your ship
</span><span class="w">  </span><span class="p">(</span><span class="nf">steer-ship!</span><span class="w"> </span><span class="n">treasure-location</span><span class="p">))</span><span class="w">
</span></code></pre>
</div>

<h4 id="section-7">函数体</h4>

<p>函数体是可以包含任何form的, 并且返回最后一个form的计算结果. 如下例:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">illustrative-function</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">304</span><span class="p">)</span><span class="w">
  </span><span class="mi">30</span><span class="w">
  </span><span class="s">"joe"</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">illustrative-function</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "joe"
</span></code></pre>
</div>

<p>下面是另外一个使用<code class="highlighter-rouge">if</code>的例子:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">number-comment</span><span class="w">
  </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">
    </span><span class="s">"Oh my gosh! What a big number!"</span><span class="w">
    </span><span class="s">"That number's OK, I guess"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">number-comment</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "That number's OK, I guess"
</span><span class="w">
</span><span class="p">(</span><span class="nf">number-comment</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "Oh my gosh! What a big number!"
</span></code></pre>
</div>

<h4 id="section-8">所有函数都是平等的</h4>

<p>最后, Clojure没有特殊的的函数. <code class="highlighter-rouge">+</code>是个函数, <code class="highlighter-rouge">-</code>是个函数, <code class="highlighter-rouge">inc</code>和<code class="highlighter-rouge">map</code>也都是只是个函数. 与你所定义的函数是一样的.</p>

<p>这也佐证了Clojure的简单性. 某种程度上, Clojure很蠢, 当你调用一个函数, Clojure只会认为”map? 我才不管呢, 我只是继续执行它而已.”  所以你不必担心有没有特殊的函数, 它的规则会不会与其他函数不同.  在Clojure里, 他们都用相同的方式工作.</p>

<h4 id="section-9">匿名函数</h4>

<p>Clojure中, 可以不给函数命名. 这样的函数称为匿名函数. 创建一个匿名函数有两种途径, 其中之一为使用<code class="highlighter-rouge">fn</code>:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">param-list</span><span class="p">]</span><span class="w">
  </span><span class="n">function</span><span class="w"> </span><span class="n">body</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>看起来很像<code class="highlighter-rouge">defn</code>, 再看看其他的下面的例子:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Hi, "</span><span class="w"> </span><span class="nb">name</span><span class="p">))</span><span class="w">
     </span><span class="p">[</span><span class="s">"Darth Vader"</span><span class="w"> </span><span class="s">"Mr. Magoo"</span><span class="p">])</span><span class="w">
</span><span class="c1">; =&gt; ("Hi, Darth Vader" "Hi, Mr. Magoo")
</span><span class="w">
</span><span class="p">((</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 24
</span></code></pre>
</div>

<p>你使用<code class="highlighter-rouge">fn</code>的方式几乎和<code class="highlighter-rouge">defn</code>相同. 参数列表, 函数体的工作方式近乎相同, 也可以使用解构, 和不定参数. 你甚至可以为你的匿名函数起个名字!</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-special-multiplier</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span><span class="w">
</span><span class="p">(</span><span class="nf">my-special-multiplier</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 36
</span></code></pre>
</div>

<p>Clojure提供另一种更加简洁的方式定义一个匿名函数. 如下:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="o">#</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 24
</span></code></pre>
</div>

<p>这里有一个将匿名函数作为参数传递给map的例子:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Hi, "</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">
     </span><span class="p">[</span><span class="s">"Darth Vader"</span><span class="w"> </span><span class="s">"Mr. Magoo"</span><span class="p">])</span><span class="w">
</span><span class="c1">; =&gt; ("Hi, Darth Vader" "Hi, Mr. Magoo")
</span></code></pre>
</div>

<p>这种奇怪的编写匿名函数的风格是通过一个名为reader macros的功能实现的. 你将学习第7章中的所有内容. 现在, 可以学习如何使用这些匿名函数.</p>

<p>你可以看到, 这种语法肯定更紧凑, 但它也有点奇怪. 它看起来很像一个函数调用, 除了开头的<code class="highlighter-rouge">#</code>外:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="c1">;; Function call
</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">

</span><span class="c1">;; Anonymous function
</span><span class="o">#</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>这样的结构可以使匿名函数可以更清晰的解析出匿名函数. <code class="highlighter-rouge">%</code>是表示传递给函数的参数. 如果有多个参数需要传递, 则可以这样:%1, %2, %3</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">%1</span><span class="w"> </span><span class="s">" and "</span><span class="w"> </span><span class="n">%2</span><span class="p">)</span><span class="w"> </span><span class="s">"cornbread"</span><span class="w"> </span><span class="s">"butter beans"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "cornbread and butter beans"
</span></code></pre>
</div>

<p>等效于<code class="highlighter-rouge">%&amp;</code>:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">identity</span><span class="w"> </span><span class="n">%</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"blarg"</span><span class="w"> </span><span class="no">:yip</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; (1 "blarg" :yip)
</span></code></pre>
</div>

<p>在这种情况下, identity函数使用了不定参数列表. Identity返回它给出的参数而不改变它. Rest参数存储为列表, 因此函数应用程序返回所有参数的列表.</p>

<p>如果你需要写一个简单的匿名函数, 使用这种风格是最好的, 因为它在视觉上紧凑. 另一方面, 如果你正在写一个更长, 更复杂的函数, 它很容易变得不可读. 如果是这样, 请使用fn</p>

<h4 id="returning-functions">Returning Functions</h4>

<p>到目前为止, 你已经看到函数可以返回其他函数. 返回的函数是闭包, 这意味着它们可以访问创建函数时在作用域中的所有变量.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">inc-maker</span><span class="w">
  </span><span class="s">"Create a custom incrementor"</span><span class="w">
  </span><span class="p">[</span><span class="n">inc-by</span><span class="p">]</span><span class="w">
  </span><span class="o">#</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">inc-by</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">inc3</span><span class="w"> </span><span class="p">(</span><span class="nf">inc-maker</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">inc3</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 10
</span></code></pre>
</div>

<h3 id="pulling-it-all-together">Pulling It All Together</h3>

<p>现在可以利用新所学的知识实现一些功能了: 做一个打地鼠的游戏(原文为打霍比特人! 我不知道霍比特人招谁惹谁了). 首先, 你需要创建一个模型用来描述地鼠的身体的各个部分. 每个身体部位包含了部位大小以及被击中的可能性等参数. 为了尽可能的重用, 地鼠的模型将仅包含左脚, 左耳等属性. 所以, 你需要一个函数来创建右脚, 右耳等属性. 最后, 你还需要创建一个函数, 它会遍历身体的每个部分并随机选择一个并hit it. 此外, 你将学习一些新的Clojure知识点: <code class="highlighter-rouge">let</code>表达式, 循环以及正则表达式.</p>

<h4 id="the-shires-next-top-model">The Shire’s Next Top Model</h4>

<p>下面就是我们的地鼠的模型(霍比特人!):</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">asym-hobbit-body-parts</span><span class="w"> </span><span class="p">[{</span><span class="no">:name</span><span class="w"> </span><span class="s">"head"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-eye"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-ear"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"mouth"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"nose"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"neck"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-shoulder"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-upper-arm"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"chest"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"back"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-forearm"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="n">d</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"abdomen"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">6</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-kidney"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-hand"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-knee"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-thigh"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-lower-leg"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-achilles"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-foot"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}])</span><span class="w">
</span></code></pre>
</div>

<p>这是包含map的数组(vector). 每个map有关于身体部位的描述以及其大小.</p>

<p>我们只定义了身体的左边部分, 而忽略了右边的(如右眼, 右耳之类的), 我们来完成它. 下面这段代码是你迄今为止见过的最复杂的, 并且引入了一些新的概念. 让我们一句一句的看看:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="c1">;; 3-1. The matching-part and symmetrize-body-parts functions
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">matching-part</span><span class="w">
  </span><span class="p">[</span><span class="n">part</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/replace</span><span class="w"> </span><span class="p">(</span><span class="no">:name</span><span class="w"> </span><span class="n">part</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="s">"^left-"</span><span class="w"> </span><span class="s">"right-"</span><span class="p">)</span><span class="w">
   </span><span class="no">:size</span><span class="w"> </span><span class="p">(</span><span class="no">:size</span><span class="w"> </span><span class="n">part</span><span class="p">)})</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">symmetrize-body-parts</span><span class="w">
  </span><span class="s">"Expects a seq of maps that have a :name and :size"</span><span class="w">
  </span><span class="p">[</span><span class="n">asym-body-parts</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">remaining-asym-parts</span><span class="w"> </span><span class="n">asym-body-parts</span><span class="w">
         </span><span class="n">final-body-parts</span><span class="w"> </span><span class="p">[]]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="n">remaining-asym-parts</span><span class="p">)</span><span class="w">
      </span><span class="n">final-body-parts</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">part</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">remaining</span><span class="p">]</span><span class="w"> </span><span class="n">remaining-asym-parts</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">remaining</span><span class="w">
               </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="n">final-body-parts</span><span class="w">
                     </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">[</span><span class="n">part</span><span class="w"> </span><span class="p">(</span><span class="nf">matching-part</span><span class="w"> </span><span class="n">part</span><span class="p">)])))))))</span><span class="w">
</span></code></pre>
</div>
<p>当我们调用函数<code class="highlighter-rouge">symmetrize-body-parts</code>并把<code class="highlighter-rouge">asym-hobbit-body-parts</code>作为参数传入后, 我们就会获得一个完整的(包含左右躯体的)地鼠对象:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">symmetrize-body-parts</span><span class="w"> </span><span class="n">asym-hobbit-body-parts</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; [{:name "head", :size 3}
</span><span class="w">      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-eye"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"right-eye"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-ear"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"right-ear"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"mouth"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"nose"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"neck"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-shoulder"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"right-shoulder"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-upper-arm"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"right-upper-arm"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"chest"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"back"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-forearm"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"right-forearm"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"abdomen"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">6</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-kidney"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"right-kidney"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-hand"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"right-hand"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-knee"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"right-knee"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-thigh"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"right-thigh"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-lower-leg"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"right-lower-leg"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-achilles"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"right-achilles"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-foot"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"right-foot"</span><span class="n">,</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}]</span><span class="w">
</span></code></pre>
</div>

<p>我们开始啃代码:</p>

<h4 id="let">let</h4>

<p>在上面的代码中你会发现有一个以关键字let开始的表单, 我们先举个例子弄懂这个let, 再去管上面代码的其他的部分.</p>

<p><code class="highlighter-rouge">let</code>是将值绑定到一个名字的方法, 如:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
  </span><span class="n">x</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 3
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">dalmatian-list</span><span class="w">
  </span><span class="p">[</span><span class="s">"Pongo"</span><span class="w"> </span><span class="s">"Perdita"</span><span class="w"> </span><span class="s">"Puppy 1"</span><span class="w"> </span><span class="s">"Puppy 2"</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">dalmatians</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">dalmatian-list</span><span class="p">)]</span><span class="w">
  </span><span class="n">dalmatians</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; ("Pongo" "Perdita")
</span></code></pre>
</div>

<p>在第一个例子中, 我们将值<code class="highlighter-rouge">3</code>绑定到<code class="highlighter-rouge">x</code>上. 第二个例子, 将会把<code class="highlighter-rouge">(take 2 dalmatian-list)</code>的计算结果作为值绑定到<code class="highlighter-rouge">dalmatians</code>上. 来看看let的作用域:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 1
</span></code></pre>
</div>

<p>首先, 我们使用<code class="highlighter-rouge">def</code>将<code class="highlighter-rouge">x</code>绑定值为<code class="highlighter-rouge">0</code>. 接着, 使用<code class="highlighter-rouge">let</code>绑定值为<code class="highlighter-rouge">1</code>(在一个新的作用域里). 所谓作用域, 类似于上下文的名称含义. For example, 在短语”please clean up these butts”, “butts” 这个词, 在你身处一个产科病房和在香烟库房的时候意义是不同的. 这段代码中, <code class="highlighter-rouge">x</code>在全局的值为<code class="highlighter-rouge">0</code>, 在let表达式内的值为<code class="highlighter-rouge">1</code>. (译者: 其实罗里吧嗦就是个局部变量的概念)</p>

<p>你可以将一个已有的绑定名称应用到新的绑定中:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">x</span><span class="p">)]</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 1
</span></code></pre>
</div>

<p>本例中, <code class="highlighter-rouge">(inc x)</code>中的<code class="highlighter-rouge">x</code>是指的<code class="highlighter-rouge">(def x 0)</code>中定义的<code class="highlighter-rouge">x</code>. 所以计算结果为1. 在<code class="highlighter-rouge">let</code>的作用域内 <code class="highlighter-rouge">x</code>的值为1而不是0.</p>

<p><code class="highlighter-rouge">let</code>中, 一样可以使用后不定参数:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">pongo</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">dalmatians</span><span class="p">]</span><span class="w"> </span><span class="n">dalmatian-list</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">pongo</span><span class="w"> </span><span class="n">dalmatians</span><span class="p">])</span><span class="w">
</span><span class="c1">; =&gt; ["Pongo" ("Perdita" "Puppy 1" "Puppy 2")]
</span></code></pre>
</div>
<p>注意, <code class="highlighter-rouge">let</code>form的值是最后一个被计算的表达式的值. let form 遵从所有的解构规则. 本例中, [pongo &amp; dalmatians] 是 <code class="highlighter-rouge">dalmatian-list</code>的解构, 将”Pongo”绑定到<code class="highlighter-rouge">pongo</code>上,<code class="highlighter-rouge">dalmatian-list</code>其他值绑定到<code class="highlighter-rouge">dalmatians</code>上. 因为<code class="highlighter-rouge">[pongo dalmatians]</code>是<code class="highlighter-rouge">let</code>的最后一个表达式, 所以let form的值就是<code class="highlighter-rouge">[pongo dalmatians]</code>.</p>

<p>let forms have two main uses. First, they provide clarity by allowing you to name things. Second, they allow you to evaluate an expression only once and reuse the result. This is especially important when you need to reuse the result of an expensive function call, like a network API call. It’s also important when the expression has side effects.</p>

<p>来看看代码3-1中的<code class="highlighter-rouge">let</code>form到底起到什么作用:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">part</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">remaining</span><span class="p">]</span><span class="w"> </span><span class="n">remaining-asym-parts</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">remaining</span><span class="w">
         </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="n">final-body-parts</span><span class="w">
               </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">[</span><span class="n">part</span><span class="w"> </span><span class="p">(</span><span class="nf">matching-part</span><span class="w"> </span><span class="n">part</span><span class="p">)]))))</span><span class="w">    
</span></code></pre>
</div>

<p>这段代码告诉Clojure, 创建一个新的作用域, 在此作用域里, 将<code class="highlighter-rouge">remaining-asym-parts</code>的第一个元素命名为<code class="highlighter-rouge">part</code>, 剩余元素命名为<code class="highlighter-rouge">remaining</code>. 函数体中的<code class="highlighter-rouge">recur</code>后文会讲.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="n">final-body-parts</span><span class="w">
  </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">[</span><span class="n">part</span><span class="w"> </span><span class="p">(</span><span class="nf">matching-part</span><span class="w"> </span><span class="n">part</span><span class="p">)]))</span><span class="w">
</span></code></pre>
</div>

<p><code class="highlighter-rouge">set</code>函数创建一个set结构用来储存<code class="highlighter-rouge">part</code>. 然后, <code class="highlighter-rouge">into</code>是将生成的set添加到<code class="highlighter-rouge">final-body-parts</code>中去. 这里使用set是为了用来排除<code class="highlighter-rouge">part</code>和<code class="highlighter-rouge">(matching-part part)</code>中的重复元素, 下面是个关于<code class="highlighter-rouge">into</code>的例子:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">[]</span><span class="w">  </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:a</span><span class="p">]))</span><span class="w">
</span><span class="c1">; =&gt; [:a]
</span></code></pre>
</div>

<p>首先, <code class="highlighter-rouge">(set [:a :a])</code>返回set<code class="highlighter-rouge">#{:a}</code>, 然后<code class="highlighter-rouge">(into [] #{:a})</code>计算的<code class="highlighter-rouge">[:a]</code>.</p>

<p>说回到<code class="highlighter-rouge">let</code>: <code class="highlighter-rouge">part</code>在函数体里使用了多次, 如果不用let, 代码将变得难以读懂:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">remaining-asym-parts</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="n">final-body-parts</span><span class="w">
             </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">[(</span><span class="nb">first</span><span class="w"> </span><span class="n">remaining-asym-parts</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">matching-part</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">remaining-asym-parts</span><span class="p">))])))</span><span class="w">
</span></code></pre>
</div>

<p>所以, <code class="highlighter-rouge">let</code>是个通过引入局部变量, 使代码变得易读的有效方法.</p>

<h4 id="loop">loop</h4>

<p>在函数<code class="highlighter-rouge">symmetrize-body-parts</code>中我们使用到了<code class="highlighter-rouge">loop</code>, <code class="highlighter-rouge">loop</code>提供了一种递归循环的实现方式. 看看下例:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">iteration</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Iteration "</span><span class="w"> </span><span class="n">iteration</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Goodbye!"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">iteration</span><span class="p">))))</span><span class="w">
</span><span class="c1">; =&gt; Iteration 0
; =&gt; Iteration 1
; =&gt; Iteration 2
; =&gt; Iteration 3
; =&gt; Iteration 4
; =&gt; Goodbye!
</span></code></pre>
</div>
<p>第一行中, <code class="highlighter-rouge">loop [iteration 0]</code>, 初始化值并开始循环. 第一次循环中, <code class="highlighter-rouge">iteration</code>的值为0. 然后第二行, 会有一个打印输出. 第三行, 检查<code class="highlighter-rouge">iteration</code>的值是否大于3, 如果大于3就跳出循环. 如果不大于3, 就重复这个过程. 这很像<code class="highlighter-rouge">loop</code>创建了一个参数是<code class="highlighter-rouge">iteration</code>的匿名函数, 而<code class="highlighter-rouge">recur</code>则像把值<code class="highlighter-rouge">(inc iteration)</code>作为参数传给这个匿名函数并调用它.</p>

<p>你可以通过使用普通的函数定义来完成同样的事情:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">recursive-printer</span><span class="w">
  </span><span class="p">([]</span><span class="w">
     </span><span class="p">(</span><span class="nf">recursive-printer</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">iteration</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">iteration</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Goodbye!"</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nf">recursive-printer</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">iteration</span><span class="p">)))))</span><span class="w">
</span><span class="p">(</span><span class="nf">recursive-printer</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; Iteration 0
; =&gt; Iteration 1
; =&gt; Iteration 2
; =&gt; Iteration 3
; =&gt; Iteration 4
; =&gt; Goodbye!
</span></code></pre>
</div>

<p>如你所见, 这样的实现使代码看起来更加冗长. 而且, loop的性能更好. In our symmetrizing function, we’ll use loop to go through each element in the asymmetrical list of body parts.</p>

<h4 id="section-10">正则表达式</h4>

<p>正则表达式是用于对文本模式匹配的工具. 它的表示方法如下:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="o">#</span><span class="s">"regular-expression"</span><span class="w">
</span></code></pre>
</div>

<p>代码3-1中, <code class="highlighter-rouge">clojure.string/replace</code>函数调用中, 为了将”left-“替换为”right-“, 使用正则表达式<code class="highlighter-rouge">#"^left-"</code>来匹配以”left-“开头的字符串. <code class="highlighter-rouge">^</code>符号是正则表达式用来匹配只有字符串开头的, 也就是只有以”left-“开头的字符串才会被匹配到. 您可以使用<code class="highlighter-rouge">re-find</code>函数来测试这一点, 它检查字符串是否与正则表达式描述的模式匹配, 如果没有匹配则返回nil:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">re-find</span><span class="w"> </span><span class="o">#</span><span class="s">"^left-"</span><span class="w"> </span><span class="s">"left-eye"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; "left-"
</span><span class="w">
</span><span class="p">(</span><span class="nb">re-find</span><span class="w"> </span><span class="o">#</span><span class="s">"^left-"</span><span class="w"> </span><span class="s">"cleft-chin"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="nb">re-find</span><span class="w"> </span><span class="o">#</span><span class="s">"^left-"</span><span class="w"> </span><span class="s">"wongleblart"</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; nil
</span></code></pre>
</div>

<p>下面是使用正则表达式将“left-”替换为“right-”的几个示例:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">matching-part</span><span class="w">
  </span><span class="p">[</span><span class="n">part</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/replace</span><span class="w"> </span><span class="p">(</span><span class="no">:name</span><span class="w"> </span><span class="n">part</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="s">"^left-"</span><span class="w"> </span><span class="s">"right-"</span><span class="p">)</span><span class="w">
   </span><span class="no">:size</span><span class="w"> </span><span class="p">(</span><span class="no">:size</span><span class="w"> </span><span class="n">part</span><span class="p">)})</span><span class="w">
</span><span class="p">(</span><span class="nf">matching-part</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-eye"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
</span><span class="c1">; =&gt; {:name "right-eye" :size 1}]
</span><span class="w">
</span><span class="p">(</span><span class="nf">matching-part</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"head"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="c1">; =&gt; {:name "head" :size 3}]
</span></code></pre>
</div>

<h4 id="section-11">让地鼠模型对称起来</h4>

<p>让我们回到填充地鼠模型的方法的细节中去:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">asym-hobbit-body-parts</span><span class="w"> </span><span class="p">[{</span><span class="no">:name</span><span class="w"> </span><span class="s">"head"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-eye"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-ear"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"mouth"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"nose"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"neck"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-shoulder"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-upper-arm"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"chest"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"back"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-forearm"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"abdomen"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">6</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-kidney"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-hand"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-knee"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-thigh"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-lower-leg"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-achilles"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"left-foot"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="mi">2</span><span class="p">}])</span><span class="w">


</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">matching-part</span><span class="w">
  </span><span class="p">[</span><span class="n">part</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/replace</span><span class="w"> </span><span class="p">(</span><span class="no">:name</span><span class="w"> </span><span class="n">part</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="s">"^left-"</span><span class="w"> </span><span class="s">"right-"</span><span class="p">)</span><span class="w">
   </span><span class="no">:size</span><span class="w"> </span><span class="p">(</span><span class="no">:size</span><span class="w"> </span><span class="n">part</span><span class="p">)})</span><span class="w">

</span><span class="err">➊</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">symmetrize-body-parts</span><span class="w">
  </span><span class="s">"Expects a seq of maps that have a :name and :size"</span><span class="w">
  </span><span class="p">[</span><span class="n">asym-body-parts</span><span class="p">]</span><span class="w">
</span><span class="err">➋</span><span class="w">   </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">remaining-asym-parts</span><span class="w"> </span><span class="n">asym-body-parts</span><span class="w"> 
         </span><span class="n">final-body-parts</span><span class="w"> </span><span class="p">[]]</span><span class="w">
</span><span class="err">➌</span><span class="w">     </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="n">remaining-asym-parts</span><span class="p">)</span><span class="w"> 
      </span><span class="n">final-body-parts</span><span class="w">
</span><span class="err">➍</span><span class="w">       </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">part</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">remaining</span><span class="p">]</span><span class="w"> </span><span class="n">remaining-asym-parts</span><span class="p">]</span><span class="w"> 
</span><span class="err">➎</span><span class="w">         </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">remaining</span><span class="w"> 
               </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="n">final-body-parts</span><span class="w">
                     </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">[</span><span class="n">part</span><span class="w"> </span><span class="p">(</span><span class="nf">matching-part</span><span class="w"> </span><span class="n">part</span><span class="p">)]))</span><span class="w">
</span></code></pre>
</div>

<p>函数<code class="highlighter-rouge">symmetrize-body-parts</code>(➊处)采用了在指令式编程中常用的方法. 就是不断的使用尾递归的方式把一个集合从第一个元素开始一个一个的处理.</p>

<p>循环是从➋处开始的. 集合的剩余部分被绑定到了<code class="highlighter-rouge">remaining-asym-parts</code>上. <code class="highlighter-rouge">remaining-asym-parts</code>的初始值为<code class="highlighter-rouge">asym-body-parts</code>, 另外一个用来输出结果的集合<code class="highlighter-rouge">final-body-parts</code>初始值为一个空的vector.</p>

<p>➌处, 如果<code class="highlighter-rouge">remaining-asym-parts</code>为空了, 就意味着可以返回一个<code class="highlighter-rouge">final-body-parts</code>的最终结果了. 否则, 就把remaining-asym-parts拆成两部分: 头和剩余的部分.</p>

<p>➎处, 吧remaining作为下一次循环的remaining-asym-parts的值, into表达式中则处理final-body-parts的结果.</p>

<p>如果你是从未接触过函数式编程, 这段代码可能需要一些时间来理解. 坚持下去! 一旦你了理解了, 你会觉得像中了百万元的彩票一样兴奋.</p>

<h4 id="reduce">使用reduce优化</h4>

<p>这种吧每一次迭代的结果作为下一次迭代的参数是一种很常见的模式, 在clojure中有一个内置函数<code class="highlighter-rouge">reduce</code>实现了这种模式:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="c1">;; sum with reduce
</span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span><span class="c1">; =&gt; 10
</span></code></pre>
</div>

<p>等效于:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p><code class="highlighter-rouge">reduce</code>函数会按照下面的步骤工作:</p>

<p>将前两个元素作为给定函数的参数计算. 上例中就是<code class="highlighter-rouge">(+ 1 2)</code>. 然后将计算的结果和序列中的下一个函数作为参数传入给定的函数. 上例中<code class="highlighter-rouge">(+ 1 2)</code>结果为3, 然后第三个元素为3, 于是等效于<code class="highlighter-rouge">(+ 3 3)</code>. 依此类推, 直到序列的最后一个元素. reduce还可以有一个可选参数 - 初始值:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span></code></pre>
</div>
<p>如果提供了初始值, 则reduce通过将给定函数应用于初始值和序列的第一个元素而不是序列的前两个元素来开始.</p>

<p>这有一个细节, 本例中, reduce接受一个集合<code class="highlighter-rouge">[1 2 3 4]</code>并返回一个数字. 虽然这种传入一个集合返回一个单独的值的情况非常常见, 但也可以返回一个比传入的集合更大的集合. reduce的意义在于”处理一个集合并构建一个结果”, 但这个结果的类型可以是任何类型. 下面是一段解释reduce如何工作的代码:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-reduce</span><span class="w">
  </span><span class="p">([</span><span class="n">f</span><span class="w"> </span><span class="n">initial</span><span class="w"> </span><span class="n">coll</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">initial</span><span class="w">
          </span><span class="n">remaining</span><span class="w"> </span><span class="n">coll</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="n">remaining</span><span class="p">)</span><span class="w">
       </span><span class="n">result</span><span class="w">
       </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">f</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">remaining</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">remaining</span><span class="p">)))))</span><span class="w">
  </span><span class="p">([</span><span class="n">f</span><span class="w"> </span><span class="p">[</span><span class="n">head</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">tail</span><span class="p">]]</span><span class="w">
   </span><span class="p">(</span><span class="nf">my-reduce</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="n">tail</span><span class="p">)))</span><span class="w">
</span></code></pre>
</div>

<p>我们可以重构我们的symmetrize-body-parts函数:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">better-symmetrize-body-parts</span><span class="w">
  </span><span class="s">"Expects a seq of maps that have a :name and :size"</span><span class="w">
  </span><span class="p">[</span><span class="n">asym-body-parts</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">final-body-parts</span><span class="w"> </span><span class="n">part</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="n">final-body-parts</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">[</span><span class="n">part</span><span class="w"> </span><span class="p">(</span><span class="nf">matching-part</span><span class="w"> </span><span class="n">part</span><span class="p">)])))</span><span class="w">
          </span><span class="p">[]</span><span class="w">
          </span><span class="n">asym-body-parts</span><span class="p">))</span><span class="w">
</span></code></pre>
</div>

<p>使用reduce优化后的代码, 代码量明显减少. 你传给reduce的匿名函数只用去关心集合中的需要处理的单独元素并构建出结果. reduce的则帮你隐去了到底是要返回最终结果或是继续迭代的细节判断.</p>

<p>使用reduce也更具表现力. 如果你的代码的读者遇到循环, 他们将不能确定循环正在做什么, 除非阅读所有的代码. 但是如果他们看到reduce, 他们会立即知道代码的目的是处理集合的元素以构建结果.</p>

<p>最后, 通过将reduce过程抽象为另一个函数作为参数的函数(高阶函数), 你的程序变得更加可复用. 您可以将reduce函数作为参数传递给其他函数, 比如symmetrize-body-parts. 可以扩展成实现生成指定数量的眼睛耳朵的模型的函数.</p>

<h4 id="section-12">运行</h4>

<p>来调用我们写好的代码吧, 下面就是一段正真开始”打”地鼠的代码:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">hit</span><span class="w">
  </span><span class="p">[</span><span class="n">asym-body-parts</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">sym-parts</span><span class="w"> </span><span class="p">(</span><span class="err">➊</span><span class="n">better-symmetrize-body-parts</span><span class="w"> </span><span class="n">asym-body-parts</span><span class="p">)</span><span class="w">
        </span><span class="err">➋</span><span class="n">body-part-size-sum</span><span class="w"> </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="n">sym-parts</span><span class="p">))</span><span class="w">
        </span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="nb">rand</span><span class="w"> </span><span class="n">body-part-size-sum</span><span class="p">)]</span><span class="w">
    </span><span class="err">➌</span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[[</span><span class="n">part</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">remaining</span><span class="p">]</span><span class="w"> </span><span class="n">sym-parts</span><span class="w">
           </span><span class="n">accumulated-size</span><span class="w"> </span><span class="p">(</span><span class="no">:size</span><span class="w"> </span><span class="n">part</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">accumulated-size</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w">
        </span><span class="n">part</span><span class="w">
        </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">accumulated-size</span><span class="w"> </span><span class="p">(</span><span class="no">:size</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">remaining</span><span class="p">))))))))</span><span class="w">
</span></code></pre>
</div>
<p>➊处用于通过<code class="highlighter-rouge">asym-body-parts</code>构建完成的地鼠模型, 然后 ➋处, 用来把身体尺寸总大小计算出来. 一旦我们计算出来这个, 我们就可以根据一个数字来代表身体的一个部分了.</p>

<p><img src="http://victoriest.me/images/hobbit-hit-line.png" alt="hobbit-hit-line.png" /></p>

<p>图3-1：身体部位对应于数字范围, 如果目标位于该范围内, 则命中. 最后, 随机选择这些数字中的一个, 然后使用➌处的循环来找到并返回与数字对应的身体部位. 循环通过跟踪我们检查的部分的累积大小并检查累积大小是否大于目标来执行此操作.</p>

<p>下面是一些运行的示例:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">hit</span><span class="w"> </span><span class="n">asym-hobbit-body-parts</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; {:name "right-upper-arm", :size 3}
</span><span class="w">
</span><span class="p">(</span><span class="nf">hit</span><span class="w"> </span><span class="n">asym-hobbit-body-parts</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; {:name "chest", :size 10}
</span><span class="w">
</span><span class="p">(</span><span class="nf">hit</span><span class="w"> </span><span class="n">asym-hobbit-body-parts</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; {:name "left-eye", :size 1}
</span></code></pre>
</div>

<p>Oh my god, that poor hobbit! You monster!</p>

<h2 id="summary">Summary</h2>

<p>这一章给你一个关于CLojure的快速浏览. 现在你知道如何使用字符串,数字，地图, 关键字, vector, list和set来表示信息, 以及如何使用def和let来命名这些他们. 您已经了解了函数以及如何创建他们. 此外, 你也了解了Clojure的简单哲学, 包括其简单并一致性的语法和偏向于在原始数据类型上进行数据加工.</p>

<p>第4章将详细介绍Clojure的核心功能, 第5章解释函数式编程思维. 本章是告诉你如何写Clojure代码, 下两章这是教你如何写的漂亮.</p>

<p>我推荐你开始用Clojure写代码, 熟悉Clojure的方式中, 没有比这更好的了. The Clojure Cheat Sheet (<a href="http://clojure.org/api/cheatsheet">http://clojure.org/api/cheatsheet</a>)列出了本章所说的数据结构和内置函数, 是个很好的参考手册.</p>

<p>接下来是些练习. 如果你想获得更多的练习题, 看看这两个网站<a href="http://www.projecteuler.net/">http://www.projecteuler.net/</a>, <a href="http://www.4clojure.com/problems/">http://www.4clojure.com/problems/</a>.</p>

<h2 id="section-13">练习</h2>

<p>这些练习可以用一种有趣的方式来测试你的Clojure知识并了解更多Clojure函数. 前三个可以仅使用本章中提供的信息完成, 但最后三个将要求您使用迄今尚未涵盖的功能. 解决最后三个, 如果你真的很想编写更多的代码和探索Clojure的标准库. 如果你觉得练习太难了, 请在阅读第4章和第5章之后重新阅读, 你会发现它们更容易.</p>

<ul>
  <li>
    <p>练习使用str, vector, list, hash-map, hash-set 函数.</p>
  </li>
  <li>
    <p>写一个函数, 接受一个数字给这个数字加100并返回.</p>
  </li>
  <li>写一个名为dec-maker的函数, 让它看起来像inc-maker的减法版:
    <div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">dec9</span><span class="w"> </span><span class="p">(</span><span class="nf">dec-maker</span><span class="w"> </span><span class="mi">9</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">dec9</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">; =&gt; 1
</span></code></pre>
    </div>
  </li>
  <li>写一个名为mapset的函数, 使其工作起来像函数map, 只是返回值为一个set:
    <div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">mapset</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w">
</span><span class="c1">; =&gt; #{2 3}
</span></code></pre>
    </div>
  </li>
  <li>
    <p>创建一个类似于<code class="highlighter-rouge">symmetrize-body-parts</code>的函数, 使地鼠模型有5只眼睛, 耳朵和手臂等.</p>
  </li>
  <li>泛化上一题, 让眼睛耳朵的个数可以作为参数传入.</li>
</ul>

<blockquote>
  <p>译后续</p>

  <p>本文原文链接:<a href="http://www.braveclojure.com/do-things/">http://www.braveclojure.com/do-things/</a><br />
学习Clojure的计划已经失败了太多次了, 这次又要挑战一回. 突然萌生出, 找本好的不枯燥的入门读物来翻译一下的想法, 边学边翻译. 希望这次能坚持下去. 23333…</p>

  <p>开始这一章翻译的时候, 才知道看懂E文和翻译出来完全不是一回事, 现在读一遍自己的译文是在是太生硬了, 而且还有几段文字实在不知道咋翻译. 不过好歹大体上弄出来了, 如果有谁看不爽了请轻拍.</p>

  <p>作者的网站:<a href="http://www.braveclojure.com/">http://www.braveclojure.com/</a></p>
</blockquote>


                

              </div>
              
            </div>
          </div>
        </div>
        <div class="col-md-4 hidden-xs">
          <div class="sidebar ">
  <h2>Recent Posts</h2>
  <ul>
    
    <li><a href="/2017/03/CLOJURE-for-the-BRAVE-and-TRUE-Chapter-02-%E8%AF%91">CLOJURE-for-the-BRAVE-and-TRUE-Chapter-02[译]</a></li>
    
    <li><a href="/2017/03/CLOJURE-for-the-BRAVE-and-TRUE-Chapter-01-%E8%AF%91">CLOJURE-for-the-BRAVE-and-TRUE-Chapter-01[译]</a></li>
    
    <li><a href="/2017/02/%E6%88%91%E6%8B%8D%E7%85%A7%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%9C%A8%E6%8B%8D%E4%BB%80%E4%B9%88">我拍照的时候是在拍什么</a></li>
    
    <li><a href="/2017/02/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84nodejs+edgejs+electron%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A">客户端软件架构nodejs+edgejs+electron调查报告</a></li>
    
    <li><a href="/2017/01/%E6%88%91%E6%98%AF%E4%B8%AA%E6%87%92%E4%BA%BA%E4%B9%88-%E6%96%B0%E5%B9%B4%E7%9A%84TODO-LIST">我是个懒人么?新年的TODO LIST</a></li>
    
  </ul>
</div>

<div class="sidebar ">
  <h2>Wechat Official Accounts</h2>
  <img src="/images/qrcode_victoriest.jpg" />
</div>


<div class="sidebar ">
  <h2>Follow me</h2>
    <li>
      <a title="victoriest on Github" href="https://github.com/victoriest" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>

    <li>
      <a title="feed.xml RSS" href="/feed.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
  </ul>
</div>
<!--
<ul class="social-media">

  
    <li>
      <a title="victoriest on Github" href="https://github.com/victoriest" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title="feed.xml RSS" href="/feed.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
  

</ul>

<div class="sidebar">
  <h2>Tags</h2>
  <ul>
    
      <li><a href="/tag/golang">golang</a></li>
    
      <li><a href="/tag/tcp服务器">tcp服务器</a></li>
    
      <li><a href="/tag/clojure">clojure</a></li>
    
      <li><a href="/tag/protobuff">protobuff</a></li>
    
      <li><a href="/tag/IntelliJ">IntelliJ</a></li>
    
      <li><a href="/tag/Leiningen">Leiningen</a></li>
    
      <li><a href="/tag/storm">storm</a></li>
    
      <li><a href="/tag/zookeeper">zookeeper</a></li>
    
      <li><a href="/tag/PerSharding">PerSharding</a></li>
    
      <li><a href="/tag/一致性哈希">一致性哈希</a></li>
    
      <li><a href="/tag/分布式缓存">分布式缓存</a></li>
    
      <li><a href="/tag/负载均衡">负载均衡</a></li>
    
      <li><a href="/tag/apache">apache</a></li>
    
      <li><a href="/tag/tomcat">tomcat</a></li>
    
      <li><a href="/tag/vim">vim</a></li>
    
      <li><a href="/tag/jabber">jabber</a></li>
    
      <li><a href="/tag/java">java</a></li>
    
      <li><a href="/tag/BTrace">BTrace</a></li>
    
      <li><a href="/tag/js">js</a></li>
    
      <li><a href="/tag/摄影">摄影</a></li>
    
      <li><a href="/tag/nodejs">nodejs</a></li>
    
      <li><a href="/tag/electron">electron</a></li>
    
  </ul>
</div>
-->
        </div>
      </div>
    </div>
    

  </div>
      <footer class="footer-distributed">
      <div class="container">
        <div class="footer">
          <p>VcitoriEST &copy; 2016. Powered by <a href="http://jekyllrb.com/">jekyll,</a> <a href="https://github.com/streetturtle/jekyll-clean-dark">Jekyll Clean Dark</a></p>
          <h6>Follow me</h6>

<ul class="social-media">

  
    <li>
      <a title="victoriest on Github" href="https://github.com/victoriest" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>
  

  

  

  

  

  
    <li>
      <a title="feed.xml RSS" href="/feed.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
  

</ul>

        </div>
      </div>
    </footer>
  </body>
</html>

</div>
